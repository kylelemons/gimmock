package gimmock

import (
	"fmt"
	"os"
	"strings"
	"bytes"

	"go/ast"
	"go/token"
	"go/parser"
)

var (
	MockDependencies = []string{
		"os",
		"github.com/kylelemons/gimmock",
	}
)

type Method struct {
	Name    string
	Params  []string
	Returns []string
}

func (m *Method) String() string {
	return m.Name + "(" + strings.Join(m.Params, ", ") + ") (" + strings.Join(m.Returns, ", ") + ")"
}

type Mock struct {
	Name    string
	Methods []*Method
}

func (m *Mock) String() string {
	lines := make([]string, len(m.Methods))
	for i, met := range m.Methods {
		lines[i] = "\t" + met.String() + "\n"
	}
	return "type " + m.Name + " interface {\n" + strings.Join(lines, "") + "}"
}

func (m *Mock) MockClass() string {
	buf := bytes.NewBuffer(nil)
	w := func(format string, args ...interface{}) {
		fmt.Fprintf(buf, format, args...)
	}

	w("// Autogenerated by gimmock\n")
	w("type mock%s struct {\n", m.Name)
	w("\tcalls map[string][][]interface{}\n")
	w("\treturns map[string][][]interface{}\n")
	w("\tstubs map[string]func()[]interface{}\n")
	w("}\n")
	w("\nfunc newMock%s() *mock%s {\n", m.Name, m.Name)
	w("\treturn &mock%s{\n", m.Name)
	w("\t\tcalls: map[string][][]interface{} {\n")
	for _, meth := range m.Methods {
		w("\t\t\t%q: {},\n", meth.Name)
	}
	w("\t\t},\n")
	w("\t\treturns: map[string][][]interface{} {\n")
	for _, meth := range m.Methods {
		w("\t\t\t%q: {},\n", meth.Name)
	}
	w("\t\t},\n")
	w("\t\tstubs: map[string]func()[]interface{} {},\n")
	w("\t}\n")
	w("}\n")
	for _, meth := range m.Methods {
		w("\nfunc (this *mock%s) %s(", m.Name, meth.Name)
		for i, param := range meth.Params {
			w("arg%d %s,", i, param)
		}
		w(") (")
		for i, ret := range meth.Returns {
			w("ret%d %s,", i, ret)
		}
		w(") {\n")
		w("\tstub, calls, rets := this.stubs[%q], this.calls[%q], this.returns[%q]\n",
			meth.Name, meth.Name, meth.Name)
		w("\tif (len(calls) == 0 || len(rets) == 0) && stub == nil {\n")
		w("\t\tpanic(&gimmock.UnexpectedCall{\n")
		w("\t\t\tInterface: \"%s\",\n", m.Name)
		w("\t\t\tMethod: \"%s\",\n", meth.Name)
		w("\t\t\tArgs: []interface{}{\n")
		for i := range meth.Params {
			w("\t\t\t\targ%d,\n", i)
		}
		w("\t\t\t},\n")
		w("\t\t})\n")
		w("\t}\n")
		w("\tvar call, ret []interface{}\n")
		if len(meth.Params) > 0 {
			w("\tcall, this.calls[%q] = calls[0], calls[1:]\n", meth.Name)
			w("\tif len(call) > 0 {\n")
			for i, arg := range meth.Params {
				if strings.IndexRune(arg, ']') >= 0 {
					w("\t\t{\n")
					w("\t\t\tgots, wants := arg%d, call[%d].(%s)\n", i, i, arg)
					w("\t\t\tbad := &gimmock.WrongArgument{\n")
					w("\t\t\t\t\tInterface: \"%s\",\n", m.Name)
					w("\t\t\t\t\tMethod: \"%s\",\n", meth.Name)
					w("\t\t\t\t\tIdx: %d,\n", i)
					w("\t\t\t\t\tGot: gots,\n")
					w("\t\t\t\t\tWant: wants,\n")
					w("\t\t\t\t}\n")
					w("\t\t\tif got, want := len(gots), len(wants); got != want { panic(bad) }\n")
					w("\t\t\tfor i, want := range wants { if gots[i] != want{ panic(bad) } }\n")
					w("\t\t}\n")
				} else {
					w("\t\tif got, want := arg%d, call[%d].(%s); got != want {\n", i, i, arg)
					w("\t\t\tpanic(&gimmock.WrongArgument{\n")
					w("\t\t\t\tInterface: \"%s\",\n", m.Name)
					w("\t\t\t\tMethod: \"%s\",\n", meth.Name)
					w("\t\t\t\tIdx: %d,\n", i)
					w("\t\t\t\tGot: got,\n")
					w("\t\t\t\tWant: want,\n")
					w("\t\t\t})\n")
					w("\t\t}\n")
				}
			}
			w("\t}\n")
		} else {
			w("\t_ = call // no arguments to process\n")
		}
		if len(meth.Returns) > 0 {
			w("\tif len(rets) == 0 {\n")
			w("\t\tret = stub()\n")
			w("\t} else {\n")
			w("\t\tret, this.returns[%q] = rets[0], rets[1:]\n", meth.Name)
			w("\t}\n")
			for i, ret := range meth.Returns {
				w("\tret%d = ret[%d].(%s)\n", i, i, ret)
			}
		} else {
			w("\t_ = ret // no return values to process\n")
		}
		w("\treturn\n")
		w("}\n")
		w("\nfunc (this *mock%s) Expect%s(", m.Name, meth.Name)
		for i, param := range meth.Params {
			w("arg%d %s,", i, param)
		}
		w(") (funcs struct{\n")
		w("\tAndReturn func(")
		for i, ret := range meth.Returns {
			if i > 0 {
				w(",")
			}
			w("%s", ret)
		}
		w(") *mock%s\n", m.Name)
		w("}) {\n")
		w("\tthis.calls[%q] = append(this.calls[%q], []interface{} {\n", meth.Name, meth.Name)
		for i := range meth.Params {
			w("\t\targ%d,\n", i)
		}
		w("\t})\n")
		w("\tfuncs.AndReturn = func(")
		for i, ret := range meth.Returns {
			w("ret%d %s,", i, ret)
		}
		w(") *mock%s {\n", m.Name)
		w("\t\tthis.returns[%q] = append(this.returns[%q], []interface{} {\n", meth.Name, meth.Name)
		for i := range meth.Returns {
			w("\t\tret%d,\n", i)
		}
		w("\t\t})\n")
		w("\t\treturn this\n")
		w("\t}\n")
		w("\treturn\n")
		w("}\n")
		w("\nfunc (this *mock%s) Stub%sReturn(", m.Name, meth.Name)
		for i, ret := range meth.Returns {
			if i > 0 {
				w(",")
			}
			w("ret%d %s", i, ret)
		}
		w(") *mock%s {\n", m.Name)
		w("\t\tret := []interface{} {\n")
		for i := range meth.Returns {
			w("\t\tret%d,\n", i)
		}
		w("\t\t}\n")
		w("\tthis.stubs[%q] = func() []interface{} {\n", meth.Name)
		w("\t\treturn ret\n")
		w("\t}\n")
		w("\treturn this\n")
		w("}\n")
	}
	return buf.String()
}

func Process(filename string) (pkg string, mocks []*Mock, err os.Error) {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		return "", nil, err
	}

	var toString func(interface{}) string
	toString = func(x interface{}) (str string) {
		switch x := x.(type) {
		case *ast.BasicLit:
			return x.Value
		case *ast.Ident:
			return x.Name
		case *ast.ArrayType:
			return "[" + toString(x.Len) + "]" + toString(x.Elt)
		case *ast.MapType:
			return "map[" + toString(x.Key) + "]" + toString(x.Value)
		case *ast.SelectorExpr:
			return toString(x.X) + "." + toString(x.Sel)
		case nil:
			return ""
		default:
			// TODO(kevlar): Ellipsis (variadic functions)
			fmt.Fprintf(os.Stderr, "Unable to determine string for %T:\n", x)
			ast.Fprint(os.Stderr, fset, x, nil)
		}
		return "unknown"
	}

	pkg = toString(file.Name)

	for _, decl := range file.Decls {
		if gen, ok := decl.(*ast.GenDecl); ok && gen.Tok == token.TYPE {
			for _, spec := range gen.Specs {
				if tspec, ok := spec.(*ast.TypeSpec); ok {
					if iface, ok := tspec.Type.(*ast.InterfaceType); ok {
						mock := &Mock{
							Name: toString(tspec.Name),
						}
						mocks = append(mocks, mock)
						for _, method := range iface.Methods.List {
							meth := &Method{
								Name: toString(method.Names[0]),
							}
							mock.Methods = append(mock.Methods, meth)
							if f, ok := method.Type.(*ast.FuncType); ok {
								if f.Params != nil {
									for _, param := range f.Params.List {
										meth.Params = append(meth.Params, toString(param.Type))
									}
								}
								if f.Results != nil {
									for _, ret := range f.Results.List {
										meth.Returns = append(meth.Returns, toString(ret.Type))
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return
}


